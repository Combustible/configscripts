
"NeoBundle Scripts-----------------------------
if has('vim_starting')
  if &compatible
    set nocompatible               " Be iMproved
  endif

  " Required:
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

"""""""""""""" Begin Neobundle plugins

" 5 minute install timeout for bundles
let g:neobundle#install_process_timeout = 1500

" YouCompleteMe config file autogenerator
NeoBundle 'rdnetto/YCM-Generator'

" Easy find/replace
NeoBundle 'dkprice/vim-easygrep'

" Call graphs using cscope
NeoBundle 'hari-rangarajan/CCTree'

" File system browser
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'Xuyuanp/nerdtree-git-plugin'

" Git tools inside vim
NeoBundle 'tpope/vim-fugitive'

" Autocompletion for many file types
NeoBundle 'Valloric/YouCompleteMe', {
     \ 'build'      : {
        \ 'unix'    : './install.py --clang-completer',
        \ }
     \ }

" Local .vimrc files for projects
NeoBundle 'MarcWeber/vim-addon-local-vimrc'

" Easy commenting / uncommenting with gc
NeoBundle 'tpope/vim-commentary'

" Adds ae and ie motions to operate on the entire file
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'kana/vim-textobj-entire'

" Adds fuzzy file searching
NeoBundle 'ctrlpvim/ctrlp.vim'

" Automatic paste mode
NeoBundle 'ConradIrwin/vim-bracketed-paste'

" AnsiEsc - Lets you load files with ANSI color codes embedded in them
NeoBundle 'powerman/vim-plugin-AnsiEsc'

"NeoBundle 'Shougo/neosnippet.vim'
"NeoBundle 'Shougo/neosnippet-snippets'
""NeoBundle 'flazz/vim-colorschemes'

" You can specify revision/branch/tag.
"NeoBundle 'Shougo/vimshell', { 'rev' : '3787e5' }

""""""""""""" End Bundles

" Required:
call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck
"End NeoBundle Scripts-------------------------


if has('cscope')
	set cscopetag cscopeverbose

	if has('quickfix')
		" set cscopequickfix=s-,c-,d-,i-,t-,e-
	endif

"cnoreabbrev csa cs add
"cnoreabbrev csf cs find
"cnoreabbrev csk cs kill
"cnoreabbrev csr cs reset
"cnoreabbrev css cs show
"cnoreabbrev csh cs help

	function! LoadCscope()
		let l:dbcount=1
		let l:db = "junk"
		while (!empty(l:db))
			let l:db = findfile("cscope.out", ".;", l:dbcount)
			if (!empty(l:db))
				let path = strpart(l:db, 0, match(l:db, "/cscope.out$"))
				set nocscopeverbose " suppress 'duplicate connection' error

				" Load the cscope database into cscope
				exe "cs add " . l:db . " " . path

				set cscopeverbose
				let l:dbcount = l:dbcount + 1
			endif
		endwhile
	endfunction

	autocmd Filetype c call LoadCscope()

	function! Loadcctree()
		let l:dbcount=1
		let l:db = "junk"
		while (!empty(l:db))
			let l:db = findfile("cscope.out", ".;", l:dbcount)
			if (!empty(l:db))
				" Load the cscope database into cctree
				if (l:dbcount > 1)
					exe "CCTreeAppendDB " . l:db
				else
					exe "CCTreeLoadDB " . l:db
				endif
				let l:dbcount = l:dbcount + 1
			endif
		endwhile
	endfunction

endif


function! Astylelinux()
	exe "write"
	set autoread
	exe "!astyle --style=linux --indent=tab=8 --convert-tabs --indent-preprocessor --min-conditional-indent=3 --max-instatement-indent=60 --pad-oper --unpad-paren --pad-header --align-pointer=name --indent-namespaces --max-code-length=100 %"
	set noautoread
endfunction
function! Astyleallman()
	exe "write"
	set autoread
	exe "!astyle --style=allman --indent=tab=4 --convert-tabs --indent-preprocessor --min-conditional-indent=3 --max-instatement-indent=60 --pad-oper --unpad-paren --pad-header --align-pointer=name --indent-namespaces --max-code-length=100 %"
	set noautoread
endfunction

" For C and C++ files, set the gq autoformat command to use astyle
" Command below produces Linux kernel style code
autocmd Filetype c,cpp set formatprg=astyle\ --style=linux\ --indent=tab=8\ --convert-tabs\ --indent-preprocessor\ --min-conditional-indent=3\ --max-instatement-indent=60\ --pad-oper\ --unpad-paren\ --pad-header\ --align-pointer=name\ --indent-namespaces\ --max-code-length=100



function! TabsOn()
	set list listchars=tab:\>\ ,trail:-
endfunction
function! TabsOff()
	set nolist
endfunction

" Allow using mouse in VIM. From here:
"   https://superuser.com/questions/549930/cant-resize-vim-splits-inside-tmux
function! MouseOn()
	nunmap <C-M>
	nmap <C-M> :call MouseOff()<CR>
	set mouse+=a
	set ttymouse=xterm2
endfunction
function! MouseOff()
	nunmap <C-M>
	nmap <C-M> :call MouseOn()<CR>
	set mouse-=a
	set ttymouse=
endfunction
nmap <C-M> :call MouseOn()<CR>


" More info here: http://vim.wikia.com/wiki/Highlight_unwanted_spaces
" Show tabs that are not at the start of a line:
" Show spaces used for indenting from the start of a line, unless the next
" immediate character is a *
" highlight ExtraWhitespace ctermbg=darkgreen guibg=darkgreen
" autocmd Filetype c,cpp match ExtraWhitespace /^[^/].*[^\t]\zs\t\+\|^\zs \+\ze[^\*]/

" Remove whitespace from end of lines when saving
autocmd BufWritePre * :%s/\s\+$//e

" Show commands triggered by macros/leader shortcuts
set showcmd

" Use UTF-8 encoding
set encoding=utf-8

" Use tabs, display them with a width of four characters
set tabstop=4
set shiftwidth=4

" Text files don't use tabs
autocmd FileType text setlocal expandtab

" Allow backspacing over everything in insert mode
set bs=indent,eol,start

" Always set autoindenting on
set autoindent

" Keep lots of command line history
set history=10000

" Show the cursor position all the time
set ruler

" Show a line at the current cursor position
set cursorline

" Make search more visible
set smartcase
set incsearch
set showmatch
set hlsearch

" ZSH style autocompletion via tab
set wildmenu
set wildmode=full

" Vertical split windows open on the right instead of the left
set splitright

" If input is from stdin, assume it hasn't been modified (and thus will not require saving or ! to escape)
autocmd StdinReadPost * set nomodified

" Fix weird NERDTree characters
let g:NERDTreeDirArrows=0

" Open Ctrl-P with ,p since control+p is used by pyclewn
let g:ctrlp_map = '<leader>p'
let g:ctrlp_cmd = 'CtrlP'

" Open nerdtree with ,ne
let mapleader = ","
nmap <leader>ne :NERDTree<cr>

" Open taglist with ,tl
nmap <leader>tl :TlistToggle<cr>

" Load cctree taglist with ,cc
nmap <leader>cc :call Loadcctree()<cr>

" Edit this vimrc file with ,vi
nmap <leader>vi :tabedit $MYVIMRC<CR>

" YouCompleteMe QuickFix
nmap <leader>fi :YcmCompleter FixIt<CR>

" Quickfix mappings:
nmap <leader>co :copen<CR>
nmap <leader>cq :cclose<CR>
nmap <leader>cn :cn<CR>
nmap <leader>cp :cp<CR>

" Disable highlighting:
nmap <leader>hl :nohls<CR>

" Source the vimrc file after saving it
if has("autocmd")
	autocmd bufwritepost .vimrc source $MYVIMRC
endif

" Set YouCompleteMe semantic completer to trigger on 'Control + k'
let g:ycm_key_invoke_completion = '<c-k>'
let g:ycm_always_populate_location_list = 1
let g:ycm_autoclose_preview_window_after_insertion = 1

" Taglist plugin opens on the right, rather than the left
let Tlist_Use_Right_Window = 1

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
endif

" Control + S saves current file
nmap <c-s> :w<CR>
imap <c-s> <Esc>:w<CR>a

" Disable Q starting Ex mode
nnoremap Q <nop>

" Remap control+P and control+X to work better with Pyclewn for GDB
function! PyclewnCustomMap()
	map <C-P> :exe "Cprint " . expand("<cword>") <CR>
	vnoremap <C-P> y:Cprint <C-R><C-R>"<C-R><C-R><CR><CR>
	map <C-X> :exe "Cprint *" . expand("<cword>") <CR>
	vnoremap <C-X> y:Cprint *<C-R><C-R>"<C-R><C-R><CR><CR>
endfunction
autocmd Filetype c,cpp call PyclewnCustomMap()

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

" Rebuild PlantUML with ,ml
" let g:plantuml_executable_script='java -jar /path/to/plantuml.jar -tsvg'
" nmap <leader>ml :w<CR> :silent make<CR>

